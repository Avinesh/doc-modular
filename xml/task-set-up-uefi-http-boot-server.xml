<?xml version="1.0" encoding="UTF-8"?>
<!-- This file originates from the project https://github.com/openSUSE/doc-kit -->
<!-- This file can be edited downstream. -->

<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook51-profile.xsl"
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE article
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>

<!--metadata
 * product SLES
 * product version xyz
 * topic category/ies network, installation
 * target group(s) system administrators
 * initially published
 * last modified-->

<!-- Based on uefi-httpboot-server.xml
https://documentation.suse.com/sles/15-SP3/html/SLES-all/cha-deployment-prep-uefi-httpboot.html-->

<article xml:id="task-set-up-uefi-http-boot-server" xml:lang="en"
 role="task"
 xmlns="http://docbook.org/ns/docbook" version="5.1"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink">

 <info>
   <title>Setting up a UEFI HTTP Boot server</title>
   <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
    <dm:bugtracker>
     <dm:url>https://bugzilla.suse.com/enter_bug.cgi</dm:url>
     <dm:component>Documentation</dm:component>
     <dm:product>Product Name</dm:product>
     <dm:assignee>assignee@suse.com</dm:assignee>
    </dm:bugtracker>
    <dm:translation>no</dm:translation>
   </dm:docmanager>
 </info>

<section xml:id="environment-set-up-uefi-http-boot-server">
 <title>Environment</title>
  <para>This document applies to the following products and product versions:</para>
  <itemizedlist>
  <listitem>
   <para>&sles;&nbsp;15&nbsp;SP3, 15&nbsp;SP2, 15&nbsp;SP1, 15&nbsp;GA, 12&nbsp;SP5, 12&nbsp;SP4, 12&nbsp;SP3</para>
  </listitem>
 </itemizedlist>
</section>

 <section xml:id="introduction-set-up-uefi-http-boot-server">
  <title>Introduction</title>
   <para><!--TODO improve this intro-->
    HTTP Boot combines DNS, DHCP, and HTTP to make it possible to boot and
    deploy systems over the network. HTTP Boot can be used as a high-performance
    replacement for PXE. HTTP Boot allows to boot a server from a URI over HTTP,
    quickly transferring large files, such as the Linux kernel and root file
    system from servers outside of your local network.
   </para>
 </section>

 <section xml:id="requirements-set-up-uefi-http-boot-server">
  <title>Requirements</title>
  <itemizedlist><!-- TODO Make proper sentences -->
   <listitem>
    <para>
     The setup described here uses 192.168.111.0/24 (IPv4) and
     2001:db8:f00f:cafe::/64 (IPv6) IP subnets and the server IP addresses are
     192.168.111.1(IPv4) and 2001:db8:f00f:cafe::1/64 (IPv6) as examples. Adjust
     these values to match your specific setup.
    </para>
   </listitem>
   <listitem>
    <para>
     &sle; installed and up to date
    </para>
   </listitem>
   <listitem>
    <para>
     Network configured
    </para>
   </listitem>
   <listitem>
    <para>
     ISO available
    </para>
   </listitem>
   <listitem>
    <para>
     SSL certificate on server?
    </para>
   </listitem>
  </itemizedlist>
 </section>

 <section xml:id="configure-dns-server">
  <title>Configuring the DNS server (optional)</title>
  <para>
   Configuring the DNS server allows you to assign a user-friendly name to the
   HTTP Boot server.
  </para>
  <procedure>
   <step>
    <para>
     Install the <package>dnsmasq</package> package:
    </para>
<screen>&prompt.root;zypper install dnsmasq</screen>
   </step>
   <step>
    <para>
     Add the following lines to the <filename>/etc/dnsmasq.conf</filename> file:
    </para>
<screen>interface=eth0
addn-hosts=/etc/dnsmasq.d/hosts.conf</screen>
   </step>
   <step>
    <para>
     Assign a domain name to the IP addresses in the
     <filename>/etc/dnsmasq.d/hosts.conf</filename> file. For example:
    </para>
<screen>192.168.111.1 www.httpboot.local
2001:db8:f00f:cafe::1 www.httpboot.local</screen>
   </step>
   <step>
    <para>
     Start the DNS server:
    </para>
 <screen>&prompt.root;systemctl start dnsmasq</screen>
   </step>
  </procedure>
  <note>
   <title>Use the <phrase role="productname">shim</phrase> boot loader</title>
   <para>
    Because of a change in UEFI 2.7, we recommend using a shim boot loader from
    &sle; 15 or newer to avoid potential errors caused by the additional DNS
    node.
   </para>
  </note>
 </section>

 <section xml:id="configure-dhcp-server">
  <title>Configuring the DHCP server</title>
  <para>
   This procedure configures DHCPv4 and DHCPv6 for both HTTP Boot and PXE Boot.
  </para>
  <procedure>
   <step>
    <para>
     Install the <package>dhcp-server</package> package:
    </para>
<screen>&prompt.root;zypper install dhcp-server</screen>
   </step>
   <step>
    <para>
     Specify the network interface for the DHCPv4 and DHCPv6 servers
     in the <filename>/etc/sysconfig/dhcpd</filename> file:
    </para>
<screen>DHCPD_INTERFACE="eth0"
DHCPD6_INTERFACE="eth0"</screen>
   </step>
   <step>
    <para>
     To set up a DHCPv4 server for both PXE Boot and HTTP Boot, add the
    following configuration to the <filename>/etc/dhcpd.conf</filename> file:
    </para>
<screen>option domain-name-servers 192.168.111.1;
option routers 192.168.111.1;
default-lease-time 14400;
ddns-update-style none;
subnet 192.168.111.0 netmask 255.255.255.0 {
  range dynamic-bootp 192.168.111.100 192.168.111.120;
  default-lease-time 14400;
  max-lease-time 172800;
  class "pxeclients"{
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    next-server 192.168.111.1;
    filename "/bootx64.efi";
  }
  class "httpclients" {
    match if substring (option vendor-class-identifier, 0, 10) = "HTTPClient";
    option vendor-class-identifier "HTTPClient";
    filename "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
  }
}</screen>
    <para>
     Note that the DHCPv4 server must use the <literal>HTTPClient</literal>
     parameter for the vendor class ID, as the client uses it to identify an
     HTTP Boot offer.
    </para>
   </step>
   <step>
    <para>
     To set up the DHCPv6 server, add the following configuration to
    <filename>/etc/dhcpd6.conf</filename>:
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};
subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;
        option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
        option dhcp6.name-servers 2001:db8:f00f:cafe::1;
        option dhcp6.vendor-class 0 10 "HTTPClient";
}</screen>
    <para>
     This configuration defines the type of the boot URL, the vendor class, and
     other required options. Similar to the DHCPv4 settings, it is necessary to
     provide the boot URL, which must have an IPv6 address. It is also
     necessary to specify the vendor class option. In DHCPv6, it consists of
     the enterprise number and the vendor class data (length and the content).
     Since the HTTP Boot driver ignores the enterprise number, you can set it
     to <literal>0</literal>. The content of the vendor class data needs to be
     <literal>HTTPClient</literal>; otherwise, the client ignores the offer.
    </para>
    <para>
     Using the following configuration, it is possible to configure the DHCPv6
     server for both PXE Boot and HTTP Boot:
    </para>
<screen>option dhcp6.bootfile-url code 59 = string;
option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};

subnet6 2001:db8:f00f:cafe::/64 {
        range6 2001:db8:f00f:cafe::42:10 2001:db8:f00f:cafe::42:99;

        class "PXEClient" {
                match substring (option dhcp6.vendor-class, 6, 9);
        }

        subclass "PXEClient" "PXEClient" {
                option dhcp6.bootfile-url "tftp://[2001:db8:f00f:cafe::1]/bootloader.efi";
        }

        class "HTTPClient"; {
                match substring (option dhcp6.vendor-class, 6, 10);
        }

        subclass "HTTPClient" "HTTPClient" {
                option dhcp6.bootfile-url "http://www.httpboot.local/sle/EFI/BOOT/bootx64.efi";
                option dhcp6.name-servers 2001:db8:f00f:cafe::1;
                option dhcp6.vendor-class 0 10 "HTTPClient";
        }
 }</screen>
    <para>
     You can also match the vendor class to a specific architecture by changing
     the following line:
    </para>
<screen>        subclass "HTTPClient" "HTTPClient":Arch:00016 {</screen>
    <para>
     In this example, <literal>HTTPClient:Arch:00016</literal> refers to an
     &x86-64; HTTP Boot client. This configuration allows the server to serve
     different architectures simultaneously.
    </para>
   </step>
   <step>
    <para>
     Start the DHCP servers:
    </para>
<screen>&prompt.root;systemctl enable --now dhcpd
&prompt.root;systemctl enable --now dhcpd6</screen>
   </step>
  </procedure>
 </section>

 <section xml:id="configure-tftp-server">
  <title>Configuring the TFTP server (optional)</title>
  <para>
   You must configure a TFTP server if you want to use both PXE Boot and HTTP Boot.
  </para>
  <procedure>
   <step>
    <para>
     Install the <package>tftp</package> package:
    </para>
<screen>&prompt.root;zypper install tftp</screen>
   </step>
   <step>
    <para>
     Enable and start the TFTP service:
    </para>
<screen>&prompt.root;systemctl enable --now tftp.socket
&prompt.root;systemctl enable --now tftp.service</screen>
   </step>
   <step>
    <para>
     List the available <package>tftpboot-installation</package> packages:
    </para>
<screen>&prompt.root;zypper se tftpboot</screen>
   </step>
   <step>
    <para>
     Install the appropriate package for your version and architecture.
     For example:
    </para>
<screen>&prompt.root;zypper install tftpboot-installation-SLE-15-SP3-x86_64</screen>
   </step>
   <step>
    <para>
     Copy the content of the
     <filename>SLE-<replaceable>VERSION</replaceable>-<replaceable>ARCH</replaceable></filename>
     directory to the root directory of the TFTP server. For example:
    </para>
<screen>&prompt.root;cp -r /usr/share/tftpboot-installation/SLE-15-SP3-x86_64 /srv/tftpboot</screen>
   </step>
  </procedure>
  <para>
   For more information, see
   <filename>/usr/share/tftpboot-installation/SLE-<replaceable>VERSION</replaceable>-<replaceable>ARCH</replaceable>/README</filename>.
  </para>
 </section>

 <section xml:id="httpboot-http-server">
  <title>Configuring the HTTP server</title>
  <procedure>
   <step>
    <para>
     Install the <package>apache2</package> package:
    </para>
<screen>&prompt.root;zypper install apache2</screen>
   </step>
   <step>
    <para>
     In the HTTP boot server directory (<literal>/srv/www/htdocs/</literal>),
     create a subdirectory for the installation content. For example,
     <literal>/srv/www/htdocs/sle/</literal>:
    </para>
<screen>&prompt.user;cd /srv/www/htdocs
&prompt.user;mkdir sle</screen>
   </step>
   <step>
    <para>
     Copy all of the contents of the ISO image to the
     <literal>/srv/www/htdocs/sle/</literal> directory.
    </para>
   </step>
   <step>
    <para>
     To configure the boot menu, edit the
     <filename>/srv/www/htdocs/sle/EFI/BOOT/grub.cfg</filename> file. Use the
     following example as a reference:
    </para>
<screen> menuentry 'Installation IPv4' --class opensuse --class gnu-linux --class gnu --class os {
  set gfxpayload=keep
  echo 'Loading kernel ...'
  linuxefi /sle/boot/x86_64/loader/linux install=http://www.httpboot.local/sle
  echo 'Loading initial ramdisk ...'
  initrdefi /sle/boot/x86_64/loader/initrd
 }

 menuentry 'Installation IPv6' --class opensuse --class gnu-linux --class gnu --class os {
  set gfxpayload=keep
  echo 'Loading kernel ...'
  linuxefi /sle/boot/x86_64/loader/linux install=http://www.httpboot.local/sle ipv6only=1 ifcfg=*=dhcp6,DHCLIENT6_MODE=managed
  echo 'Loading initial ramdisk ...'
  initrdefi /sle/boot/x86_64/loader/initrd
 }</screen>
   </step>
   <step>
    <para>
     Enable and start <literal>apache2</literal>:
    </para>
<screen>&prompt.root;systemctl enable --now apache2</screen>
   </step>
  </procedure>
 </section>

 <section xml:id="httpboot-http-server-ssl-support">
  <title>Enabling SSL support for the HTTP server (optional)</title>
  <para>
   HTTPS Boot is only supported on &sle; 15 and newer. To use HTTPS Boot, you must convert an existing server certificate
   into the <literal>DER</literal> format and enroll it into the client's
   firmware.
  </para>
  <procedure>
   <step>
    <para>
     Assuming you already have a certificate installed on your server, convert
     it into the <literal>DER</literal> format for use with the client:
    </para>
<screen>&prompt.root;openssl x509 -in <replaceable>CERTIFICATE</replaceable>.crt \
-outform der -out <replaceable>CERTIFICATE</replaceable>.der</screen>
   </step>
   <step>
    <para>
     Enroll the server certificate into the client firmware.
    </para>
    <para>
     The exact procedure for enrolling the converted certificate depends on the
     specific implementation of the client's firmware. For certain hardware,
     you must enroll the certificate manually via the firmware UI using an
     external storage device with the certificate on it. Machines with Redfish
     support can enroll the certificate remotely. Consult the documentation for
     your specific hardware for more information on enrolling certificates.
    </para>
   </step>
   <step>
    <para>
     Add the SSL flag to the <filename>/etc/sysconfig/apache2</filename> file:
    </para>
<screen>APACHE_SERVER_FLAGS="SSL"</screen>
   </step>
   <step>
    <para>
     In the same file, ensure that the <literal>ssl</literal> module is listed in
     <literal>APACHE_MODULES</literal>. For example:
    </para>
<screen>APACHE_MODULES="actions alias auth_basic authn_file authz_host authz_groupfile authz_core
authz_user autoindex cgi dir env expires include log_config mime negotiation setenvif <emphasis role="bold">ssl</emphasis>
socache_shmcb userdir reqtimeout authn_core headers proxy proxy_http proxy_wstunnel"</screen>
   </step>
   <step>
    <para>
     Copy the private key and the certificate to the
     <filename>/etc/apache2/</filename> directory:
    </para>
<screen>&prompt.root;cp server.key /etc/apache2/ssl.key/
&prompt.root;chown wwwrun /etc/apache2/ssl.key/server.key
&prompt.root;chmod 600 /etc/apache2/ssl.key/server.key
&prompt.root;cp server.crt /etc/apache2/ssl.crt/</screen>
   </step>
   <step>
    <para>
     Create the SSL vhost configuration:
    </para>
<screen>&prompt.root;cd /etc/apache2/vhosts.d
&prompt.root;cp vhost-ssl.template vhost-ssl.conf</screen>
   </step>
   <step>
    <para>
     Change the private key and the certificate in the
     <filename>/etc/apache2/vhosts.d/vhost-ssl.conf</filename>
     file to the following values:
    </para>
<screen>SSLCertificateFile /etc/apache2/ssl.crt/server.crt
SSLCertificateKeyFile /etc/apache2/ssl.key/server.key</screen>
   </step>
   <step>
    <para>
     Restart Apache to activate the SSL support:
    </para>
<screen>&prompt.root;systemctl restart apache2</screen>
   </step>
   <step>
    <para>
     Replace the <literal>http://</literal> prefix with
     <literal>https://</literal> in <filename>dhcpd.conf</filename>
     and <filename>dhcpd6.conf</filename>.
    </para>
   </step>
   <step>
    <para>
     Restart the DHCP server:
    </para>
<screen>&prompt.root;systemctl restart dhcpd
&prompt.root;systemctl restart dhcpd6</screen>
   </step>
  </procedure>
 </section>

 <section xml:id="summary-set-up-uefi-http-boot-server">
  <title>Summary</title>
  <para><!-- TODO Expand and improve -->
   Enabling HTTP Boot on a physical client machine depends on your specific
   hardware. Consult the documentation for further information on how to
   enable HTTP Boot on your particular machine.
  </para>
  <para>
   If the firmware already supports HTTP boot, plug in the cable and choose the
   correct boot option.
  </para>
 </section>

 <section xml:id="troubleshooting-set-up-uefi-http-boot-server">
  <title>Troubleshooting</title>
  <variablelist>
   <varlistentry>
    <term>Problem phrased as question</term>
    <listitem>
     <para>
      If DHCPv6 packets are dropped by the RP filter in the firewall, check its
      log. In case it contains the <literal>rpfilter_DROP</literal> entry,
      disable the filter using the following configuration in
      <filename>/etc/firewalld/firewalld.conf</filename>:
     </para>
     <screen>IPv6_rpfilter=no</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Another problem phrased as question</term>
    <listitem>
     <para>
      Another paragraph of text.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </section>

 <section xml:id="next-set-up-uefi-http-boot-server">
  <title>Next steps</title>
  <itemizedlist>
   <listitem>
    <para>
     An
    </para>
   </listitem>
   <listitem>
    <para>
     Unordered
    </para>
   </listitem>
   <listitem>
    <para>
     List
    </para>
   </listitem>
  </itemizedlist>
 </section>

 <section xml:id="related-set-up-uefi-http-boot-server">
  <title>Related topics</title>
  <itemizedlist>
   <listitem>
    <para>
     Setting up a PXE boot server
    </para>
   </listitem>
   <listitem>
    <para>
     Unordered
    </para>
   </listitem>
   <listitem>
    <para>
     List
    </para>
   </listitem>
  </itemizedlist>
 </section>
</article>
